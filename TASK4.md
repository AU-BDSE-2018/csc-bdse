## Задание 4
Необходимо реализовать `KeyValueApi` с функцией разделения пространства хранимых пар ключ-значение по кластеру из 
нижележащих нод (N > 1). Подобное разделение называется партиционированием: все множество ключей делится на 
части - партиции, для хранилища в каждый момент известно на каком из составляющих кластер Key-value Persistent Storage 
Unit находится часть (несколько партиций при этом могут находится на одной нижележащей ноде). Для облегчения 
задачи поставляется интерфейс `Partitioner`, описывающий преобразование ключа в партицию, и три его реализации:
- `FirstLetterPartitioner`, на основе интервалов начальных символов ключа 
- `ModNPartitioner`, на основе хеш-кода ключа и деления по модулю
- `ConsistentHashMd5Partitioner`, на основе консистентного хеширования (https://en.wikipedia
.org/wiki/Consistent_hashing)

Партиционированный `KeyValueApi`, который требуется реализовать, имеет статическую конфигурацию:
- список нод `List[KeyValueApi]`, составляющих кластер. Каждая нода обслуживает одну или более партиции, 
использование имени ноды в качестве имени партиции допустимо 
- timeout - максимальное время выполнения операции с `KeyValueApi`   
- partitioner - алгоритм определения партиции из ключа (один из указанных выше)

Логика определения нижлежащей ноды, с которой нужно производить операции для конкретного ключа, содержится в 
надстройке-координаторе. Координатор находится на каждой из нижележащих нод, клиент, использующий партиционированное
 хранилище, может обращаться к любому из координаторов с одинаковым результатом. Координаторы инициализируются 
 одинаковой конфигурацией (описана выше), не меняют ее в ходе работы. Отказ нод моделируется через 
 создание кластера с новой конфигурацией, например:
- cluster1: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = ModNPartitioner)
- cluster2: PartitionedKeyValueApi(List(node0, node2), timeout = 3s, partitioner = ModNPartitioner)

Кластер версии 2 моделирует отказ node1 в кластере версии 1 (при неизменности нижлежащих нод), ключи должны быть 
перераспределены. Важной составляющей практического задания является проверка в тестах количества ключей, 
перемещенных в результате удаления/добавления нод в кластер и перепартиционирования ключей (в идеальном случае  
перемещается не более K/N ключей, где K - общее их число, N - число нод). Для практического задания значения в парах 
key-value не играют существенной роли, рекомендуется вариант когда в значении содержится байты ключа.  
   
### Требуется:
- синхронизировать {your-awesome-team-fork-repo} c upstream для получения обновленных файлов https://help.github
.com/articles/syncing-a-fork/, устранить конфликты в результате merge 
- сделать бранч `csc-bdse-task4` где будет находиться сдаваемый материал для третьего задания
- создать реализацию партиционированного `KeyValueApi`, включающую:
  - получения и использование конфигурации - списка адресов нод Persistent Storage Unit (`List[KeyValueApi]`), timeout, 
  partitioner
  - координатор в виде надстройки для каждой из нод с функцией маршрутизации запросов в нижележайшие ноды. Операции 
  записи, чтения и удаления по ключу производятся с нодой соотнесенной с партицией ключа. Операция получения списка 
  ключей производит обращение ко всем нодам и объединяет результат. Операции получения информации и выполнения команд
   выполняют, соотвественно, опрос нод кластера и отправку команды на соотнесенную с командой ноду.
  - HTTP API партиционированного координатора 
- создать расширение `KeyValueApiHttpClient` для работы со списком нод-координаторов. Клиент работает со списком 
равнозначных нод-координаторов, если происходит ошибка связи с координатором 1, то перация исполняется на 
координаторе 2 и далее. Если аналогичный клиент уже реализован в задании 3, повтороной реализации не потребуется.   
- создать интеграционные тесты (`PartitionedKeyValueApiHttpClientTest`) записи, чтения и удаления на кластере с 
партиционированием (предполагается поднимается в контейнерах) в конфигурациях:
 - cluster1: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = FirstLetterPartitioner),
  cluster2: PartitionedKeyValueApi(List(node0, node2), timeout = 3s, partitioner = FirstLetterPartitioner). 
  Моделирует отключение одной ноды при партиционировании по начальному символу ключа
 - cluster1: PartitionedKeyValueApi(List(node0, node1, node2, node3, node4), timeout = 3s, partitioner = 
 ModNPartitioner), cluster2: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = 
 ModNPartitioner). Моделирует отключение двух нод при партиционировании по modN(хеш-код ключа)
 - cluster1: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = FirstLetterPartitioner),
  cluster2: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = ModNPartitioner). 
  Моделирует смену схемы партиционирования
 - cluster1: PartitionedKeyValueApi(List(node0, node1, node2), timeout = 3s, partitioner = ConsistentHashMd5Partitioner),
  cluster2: PartitionedKeyValueApi(List(node0, node2), timeout = 3s, partitioner = ConsistentHashMd5Partitioner). 
  Моделирует отключение одной ноды при консистентном хешировании
- описать в `INSTALL_TASK4.md` специфику сборки приложений и запуска интеграционных тестов
- описать в `README_TASK4.md` что было реализовано, описание проблем, не решенных в коде и требующих дальнейшего 
рассмотрения, неявных моментов. Обязательно добавить название и список участников команды.  
- прислать PR {your-awesome-team-fork-repo}/csc-bdse-task4 => {your-awesome-team-fork-repo}/master (добавить alesavin, 
dormidon, semkagtn, 747mmHg в ревьюеры)  
- добавить ссылку на PR в топик задания 4 курса на https://compscicenter.ru       

### Дополнительно:
- реализация партиционированного контроллера, работающего над реплицированными контроллерами из задания 3. 
Предполагается что партиции дублированы на разных нодах. 

